name: Enhanced Cross-Branch PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, closed, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to revalidate (optional - validates all if empty)'
        required: false
      issue_number:
        description: 'Issue number to revalidate all related PRs (optional)'
        required: false

# Configuration: Update these for each release cycle
env:
  PRIMARY_BRANCH: 'main'
  RELEASE_BRANCH: 'checking-2'
  # Validation rules
  REQUIRE_EXACT_MATCH: 'true'           # All issue refs must match exactly
  ALLOW_DRAFT_PRS: 'false'              # Include draft PRs in validation
  MAX_BRANCH_IMBALANCE: '2'             # Max difference in PR count between branches
  OVERRIDE_LABEL: 'approved:single-branch-merge'
  BLOCK_LABEL: 'merge-blocked:cross-branch-validation'

jobs:
  validate-cross-branch:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      contents: read
      statuses: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup validation context
        id: context
        run: |
          echo "timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          echo "workflow_run_id=${{ github.run_id }}" >> $GITHUB_OUTPUT
          echo "trigger_event=${{ github.event_name }}" >> $GITHUB_OUTPUT
          
          # Determine which PR triggered this (if any)
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "trigger_pr=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.pr_number }}" ]; then
            echo "trigger_pr=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "trigger_pr=none" >> $GITHUB_OUTPUT
          fi

      - name: Extract all issue references from current PR
        id: extract_issues
        if: github.event_name == 'pull_request'
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_TEXT="$PR_TITLE $PR_BODY"
          
          # Extract issue URLs from markdown hyperlinks [#N](url)
          ISSUE_URLS=$(echo "$PR_TEXT" | grep -oP '\[#\d+\]\(\K[^)]+(?=\))' | grep 'github.com.*issues' | sort -u | tr '\n' ',' | sed 's/,$//')
          
          if [ -z "$ISSUE_URLS" ]; then
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No issue references found in PR"
          else
            echo "has_issues=true" >> $GITHUB_OUTPUT
            echo "issue_refs=$ISSUE_URLS" >> $GITHUB_OUTPUT
            echo "issue_count=$(echo $ISSUE_URLS | tr ',' '\n' | wc -l)" >> $GITHUB_OUTPUT
            echo "‚úÖ Found issue URLs: $ISSUE_URLS"
          fi
      - name: Query GitHub GraphQL for all linked PRs
        id: query_linked_prs
        if: steps.extract_issues.outputs.has_issues == 'true' || github.event.inputs.issue_number
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Determine which issues to query
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUMBERS="${{ github.event.inputs.issue_number }}"
          else
            ISSUE_URLS="${{ steps.extract_issues.outputs.issue_refs }}"
            ISSUE_NUMBERS=$(echo "$ISSUE_URLS" | tr ',' '\n' | grep -oP 'issues/\K\d+' | tr '\n' ',' | sed 's/,$//')
          fi
          
          echo "Querying issues: $ISSUE_NUMBERS"
          
          # Initialize empty array for all PRs
          > all_linked_prs_temp.json
          
          # Query each issue individually using GraphQL
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUE_NUMBERS"
          for ISSUE_REF in "${ISSUE_ARRAY[@]}"; do
            ISSUE_NUM=$(echo "$ISSUE_REF" | sed 's/#//g')
            
            QUERY='query($owner: String!, $repo: String!, $issueNumber: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $issueNumber) {
                  number
                  title
                  timelineItems(itemTypes: [CROSS_REFERENCED_EVENT], first: 100) {
                    nodes {
                      ... on CrossReferencedEvent {
                        source {
                          ... on PullRequest {
                            number
                            title
                            body
                            baseRefName
                            state
                            isDraft
                            url
                            labels(first: 20) {
                              nodes {
                                name
                              }
                            }
                            author {
                              login
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }'
            
            RESULT=$(gh api graphql \
              -f query="$QUERY" \
              -f owner="${{ github.repository_owner }}" \
              -f repo="${{ github.event.repository.name }}" \
              -F issueNumber="$ISSUE_NUM" 2>&1)
            
            if [ $? -eq 0 ]; then
              echo "$RESULT" | jq -c '.data.repository.issue.timelineItems.nodes[].source' >> all_linked_prs_temp.json
            else
              echo "‚ö†Ô∏è Failed to query issue #$ISSUE_NUM"
            fi
          done
          
          # Combine all PRs and remove duplicates
          if [ -s all_linked_prs_temp.json ]; then
            jq -s 'unique_by(.number)' all_linked_prs_temp.json > all_linked_prs.json
          else
            echo "[]" > all_linked_prs.json
          fi
          rm -f all_linked_prs_temp.json
          
          # Count PRs by branch
          if [ "${{ env.ALLOW_DRAFT_PRS }}" = "false" ]; then
            FILTER_DRAFT='and .isDraft == false'
          else
            FILTER_DRAFT=''
          fi
          
          PRIMARY_PRS=$(jq -r --arg branch "${{ env.PRIMARY_BRANCH }}" \
            '.[] | select(.baseRefName == $branch and .state == "OPEN" '"$FILTER_DRAFT"') | .number' \
            all_linked_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          RELEASE_PRS=$(jq -r --arg branch "${{ env.RELEASE_BRANCH }}" \
            '.[] | select(.baseRefName == $branch and .state == "OPEN" '"$FILTER_DRAFT"') | .number' \
            all_linked_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          # Count PRs safely
          if [ -z "$PRIMARY_PRS" ] || [ "$PRIMARY_PRS" = " " ]; then
            PRIMARY_COUNT=0
            PRIMARY_PRS=""
          else
            PRIMARY_COUNT=$(echo "$PRIMARY_PRS" | wc -w)
          fi
          
          if [ -z "$RELEASE_PRS" ] || [ "$RELEASE_PRS" = " " ]; then
            RELEASE_COUNT=0
            RELEASE_PRS=""
          else
            RELEASE_COUNT=$(echo "$RELEASE_PRS" | wc -w)
          fi
          
          # Output results
          echo "primary_prs=$(echo $PRIMARY_PRS | tr ' ' ','  | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "release_prs=$(echo $RELEASE_PRS | tr ' ' ',' | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "primary_count=$PRIMARY_COUNT" >> $GITHUB_OUTPUT
          echo "release_count=$RELEASE_COUNT" >> $GITHUB_OUTPUT
          echo "total_prs=$((PRIMARY_COUNT + RELEASE_COUNT))" >> $GITHUB_OUTPUT
          
          echo "üìä PR Distribution:"
          echo "  - ${{ env.PRIMARY_BRANCH }}: $PRIMARY_COUNT PRs"
          echo "  - ${{ env.RELEASE_BRANCH }}: $RELEASE_COUNT PRs"
      - name: Filter PRs by matching issue URLs
        id: filter_prs
        if: steps.extract_issues.outputs.has_issues == 'true' && steps.query_linked_prs.outputs.total_prs > 0
        run: |
          CURRENT_ISSUE_URLS="${{ steps.extract_issues.outputs.issue_refs }}"
          echo "Current PR issue URLs: $CURRENT_ISSUE_URLS"
          
          # Convert comma-separated URLs to array for processing
          IFS=',' read -ra CURRENT_URLS_ARRAY <<< "$CURRENT_ISSUE_URLS"
          
          # Create a filtered JSON with only PRs that have matching issue URLs
          echo "[]" > filtered_prs.json
          
          # Get total number of PRs
          TOTAL_PRS=$(jq 'length' all_linked_prs.json)
          echo "Total PRs to check: $TOTAL_PRS"
          
          # Check each PR
          for ((i=0; i<$TOTAL_PRS; i++)); do
            PR_NUM=$(jq -r ".[$i].number" all_linked_prs.json)
            PR_BODY=$(jq -r ".[$i].body // empty" all_linked_prs.json)
            PR_TITLE=$(jq -r ".[$i].title // empty" all_linked_prs.json)
            PR_TEXT="$PR_TITLE $PR_BODY"
            
            echo "Checking PR #$PR_NUM..."
            
            # Extract issue URLs from this PR's body
            PR_ISSUE_URLS=$(echo "$PR_TEXT" | grep -oP '\[#\d+\]\(\K[^)]+(?=\))' | grep 'github.com.*issues' | sort -u | tr '\n' ',' | sed 's/,$//')
            
            if [ -z "$PR_ISSUE_URLS" ]; then
              echo "  PR #$PR_NUM has no issue URLs, skipping"
              continue
            fi
            
            echo "  PR #$PR_NUM issue URLs: $PR_ISSUE_URLS"
            
            # Convert PR URLs to sorted array for comparison
            IFS=',' read -ra PR_URLS_ARRAY <<< "$PR_ISSUE_URLS"
            PR_URLS_SORTED=$(printf '%s\n' "${PR_URLS_ARRAY[@]}" | sort | tr '\n' ',' | sed 's/,$//')
            CURRENT_URLS_SORTED=$(printf '%s\n' "${CURRENT_URLS_ARRAY[@]}" | sort | tr '\n' ',' | sed 's/,$//')
            
            # Check if URLs match exactly
            echo "PR_URLS_SORTED : $PR_URLS_SORTED"
            echo "CURRENT_URLS_SORTED : $CURRENT_URLS_SORTED"
            if [ "$PR_URLS_SORTED" = "$CURRENT_URLS_SORTED" ]; then
              echo "  :white_check_mark: PR #$PR_NUM has matching issue URLs"
              # Add this PR to filtered list
              jq --slurpfile existing filtered_prs.json --argjson idx "$i" \
              '$existing[0] + [.[$idx]]' all_linked_prs.json > filtered_prs_temp.json
              mv filtered_prs_temp.json filtered_prs.json
            else
              echo "  :x: PR #$PR_NUM has different issue URLs"
            fi
          done
          
          # Filter to only OPEN PRs with PRIMARY or RELEASE branch as base
          if [ "${{ env.ALLOW_DRAFT_PRS }}" = "false" ]; then
            FILTER_DRAFT='and .isDraft == false'
          else
            FILTER_DRAFT=''
          fi
          
          jq --arg primary "${{ env.PRIMARY_BRANCH }}" --arg release "${{ env.RELEASE_BRANCH }}" \
            '[.[] | select(.state == "OPEN" and (.baseRefName == $primary or .baseRefName == $release) '"$FILTER_DRAFT"')]' \
            filtered_prs.json > filtered_prs_temp.json
          mv filtered_prs_temp.json filtered_prs.json
          
          # Count filtered PRs by branch
          FILTERED_PRIMARY_PRS=$(jq -r --arg branch "${{ env.PRIMARY_BRANCH }}" \
            '.[] | select(.baseRefName == $branch) | .number' \
            filtered_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          FILTERED_RELEASE_PRS=$(jq -r --arg branch "${{ env.RELEASE_BRANCH }}" \
            '.[] | select(.baseRefName == $branch) | .number' \
            filtered_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          # Count filtered PRs safely
          if [ -z "$FILTERED_PRIMARY_PRS" ] || [ "$FILTERED_PRIMARY_PRS" = " " ]; then
            FILTERED_PRIMARY_COUNT=0
            FILTERED_PRIMARY_PRS=""
          else
            FILTERED_PRIMARY_COUNT=$(echo "$FILTERED_PRIMARY_PRS" | wc -w)
          fi
          
          if [ -z "$FILTERED_RELEASE_PRS" ] || [ "$FILTERED_RELEASE_PRS" = " " ]; then
            FILTERED_RELEASE_COUNT=0
            FILTERED_RELEASE_PRS=""
          else
            FILTERED_RELEASE_COUNT=$(echo "$FILTERED_RELEASE_PRS" | wc -w)
          fi
          
          # Output filtered results
          echo "filtered_primary_prs=$(echo $FILTERED_PRIMARY_PRS | tr ' ' ','  | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "filtered_release_prs=$(echo $FILTERED_RELEASE_PRS | tr ' ' ',' | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "filtered_primary_count=$FILTERED_PRIMARY_COUNT" >> $GITHUB_OUTPUT
          echo "filtered_release_count=$FILTERED_RELEASE_COUNT" >> $GITHUB_OUTPUT
          echo "filtered_total_prs=$((FILTERED_PRIMARY_COUNT + FILTERED_RELEASE_COUNT))" >> $GITHUB_OUTPUT
          
          echo ""
          echo ":bar_chart: Filtered PR Distribution (matching issue URLs only):"
          echo "  - ${{ env.PRIMARY_BRANCH }}: $FILTERED_PRIMARY_COUNT PRs ($FILTERED_PRIMARY_PRS)"
          echo "  - ${{ env.RELEASE_BRANCH }}: $FILTERED_RELEASE_COUNT PRs ($FILTERED_RELEASE_PRS)"
          echo ""
          echo "=== Filtered PRs JSON ==="
          cat filtered_prs.json
      - name: Validate issue reference matching
        id: validate_matching
        if: steps.filter_prs.outputs.filtered_total_prs > 0
        run: |
          PRIMARY_COUNT=${{ steps.filter_prs.outputs.filtered_primary_count }}
          RELEASE_COUNT=${{ steps.filter_prs.outputs.filtered_release_count }}
          PRIMARY_PRS="${{ steps.filter_prs.outputs.filtered_primary_prs }}"
          RELEASE_PRS="${{ steps.filter_prs.outputs.filtered_release_prs }}"
          
          echo "Primary branch (${{ env.PRIMARY_BRANCH }}): $PRIMARY_COUNT PRs"
          echo "Release branch (${{ env.RELEASE_BRANCH }}): $RELEASE_COUNT PRs"
          
          # Check if PR counts match
          if [ $PRIMARY_COUNT -eq $RELEASE_COUNT ] && [ $PRIMARY_COUNT -gt 0 ]; then
            echo "validation_result=success" >> $GITHUB_OUTPUT
            echo "matching_pr_numbers=$RELEASE_PRS" >> $GITHUB_OUTPUT
            echo "should_block=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Validation SUCCESS: PR counts match ($PRIMARY_COUNT in each branch)"
          else
            echo "validation_result=failure" >> $GITHUB_OUTPUT
            echo "matching_pr_numbers=" >> $GITHUB_OUTPUT
            echo "should_block=true" >> $GITHUB_OUTPUT
            echo "‚ùå Validation FAILURE: PR count mismatch (Primary: $PRIMARY_COUNT, Release: $RELEASE_COUNT)"
          fi
      - name: Post validation result to PR
        if: steps.validate_matching.outputs.validation_result && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const validationResult = '${{ steps.validate_matching.outputs.validation_result }}';
            const primaryCount = '${{ steps.filter_prs.outputs.filtered_primary_count }}';
            const releaseCount = '${{ steps.filter_prs.outputs.filtered_release_count }}';
            const primaryPRs = '${{ steps.filter_prs.outputs.filtered_primary_prs }}';
            const releasePRs = '${{ steps.filter_prs.outputs.filtered_release_prs }}';
            const issueRefs = '${{ steps.extract_issues.outputs.issue_refs }}';
            const targetBranch = '${{ github.event.pull_request.base.ref }}';
            const primaryBranch = '${{ env.PRIMARY_BRANCH }}';
            const releaseBranch = '${{ env.RELEASE_BRANCH }}';
            const compareBranch = targetBranch === primaryBranch ? releaseBranch : primaryBranch;
            
            let commentBody;
            
            if (validationResult === 'success') {
              commentBody = `‚úÖ **Cross-Branch Validation: PASSED**
              
              This PR references issue(s) and corresponding PR(s) exist in both branches with matching issue references.
              
              **Status:** Merge validation successful - both branches will receive this fix.
              
              ### üìä PR Distribution
              - **${primaryBranch}:** ${primaryCount} PR(s) ${primaryPRs ? `(#${primaryPRs.split(',').join(', #')})` : ''}
              - **${releaseBranch}:** ${releaseCount} PR(s) ${releasePRs ? `(#${releasePRs.split(',').join(', #')})` : ''}
              
              **Issue References:** ${issueRefs}`;
              
              // Remove blocking label
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: '${{ env.BLOCK_LABEL }}'
                });
              } catch (error) {
                // Label might not exist
              }
              
            } else {
              commentBody = `‚ö†Ô∏è **Cross-Branch Validation: REQUIRES REVIEW**
              
              This PR references issue(s) but **PR count mismatch** detected between branches.
              
              **‚ö†Ô∏è MERGE BLOCKED - REVIEWER ACTION REQUIRED**
              
              ### üìä PR Distribution
              - **${primaryBranch}:** ${primaryCount} PR(s) ${primaryPRs ? `(#${primaryPRs.split(',').join(', #')})` : ''}
              - **${releaseBranch}:** ${releaseCount} PR(s) ${releasePRs ? `(#${releasePRs.split(',').join(', #')})` : ''}
              
              **Issue References:** ${issueRefs}
              
              ---
              
              ### Override Instructions
              
              If this fix is intentionally being merged into **only** the \`${targetBranch}\` branch, a reviewer must:
              
              1. **Acknowledge the risk** of potential inconsistency between branches
              2. **Add the label** \`${{ env.OVERRIDE_LABEL }}\` to this PR
              3. **Comment** with justification for the single-branch merge
              
              **Example justification:**
              > "Approved for single-branch merge. This fix is specific to ${targetBranch} and does not apply to ${compareBranch} because [reason]."
              
              ---
              
              ### Creating a Matching PR
              
              Alternatively, create a PR for \`${compareBranch}\` that:
              - References the same issue(s)
              - Contains the equivalent fix for that branch
              
              Once the matching PR is created, re-run this workflow by updating this PR.`;
              
              // Add blocking label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['${{ env.BLOCK_LABEL }}']
              });
            }
            
            // Post or update comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Cross-Branch Validation')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
      
      - name: Check branch imbalance
        id: check_imbalance
        if: steps.query_linked_prs.outputs.total_prs > 0
        run: |
          PRIMARY_COUNT=${{ steps.query_linked_prs.outputs.primary_count }}
          RELEASE_COUNT=${{ steps.query_linked_prs.outputs.release_count }}
          MAX_IMBALANCE=${{ env.MAX_BRANCH_IMBALANCE }}
          
          IMBALANCE=$((PRIMARY_COUNT > RELEASE_COUNT ? PRIMARY_COUNT - RELEASE_COUNT : RELEASE_COUNT - PRIMARY_COUNT))
          
          echo "imbalance=$IMBALANCE" >> $GITHUB_OUTPUT
          
          if [ $IMBALANCE -gt $MAX_IMBALANCE ]; then
            echo "imbalance_exceeded=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Branch imbalance detected: $IMBALANCE (max: $MAX_IMBALANCE)"
          else
            echo "imbalance_exceeded=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Branch balance acceptable: $IMBALANCE (max: $MAX_IMBALANCE)"
          fi

      - name: Check for override approval
        id: check_override
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(label => label.name);
            const hasOverride = labels.includes('${{ env.OVERRIDE_LABEL }}');
            
            core.setOutput('override_approved', hasOverride.toString());
            
            if (hasOverride) {
              console.log('‚úÖ Override label found - validation will be bypassed');
            }
            
            return hasOverride;

      - name: Check for pending validation in comparison branch
        id: check_pending
        if: steps.query_linked_prs.outputs.total_prs > 0
        uses: actions/github-script@v7
        with:
          script: |
            const primaryPRs = '${{ steps.query_linked_prs.outputs.primary_prs }}'.split(',').filter(n => n);
            const releasePRs = '${{ steps.query_linked_prs.outputs.release_prs }}'.split(',').filter(n => n);
            const currentPR = context.payload.pull_request?.number;
            const currentBranch = context.payload.pull_request?.base?.ref;
            
            // Determine comparison PRs based on current branch
            const comparisonPRs = currentBranch === '${{ env.PRIMARY_BRANCH }}' ? releasePRs : primaryPRs;
            
            let hasPendingChecks = false;
            let pendingPRNumbers = [];
            
            // Check if comparison PRs have pending validation checks
            for (const prNum of comparisonPRs) {
              try {
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/pull/${prNum}/head`,
                  check_name: 'validate-cross-branch'
                });
                
                const latestCheck = checkRuns.check_runs[0];
                if (!latestCheck || latestCheck.status === 'queued' || latestCheck.status === 'in_progress') {
                  hasPendingChecks = true;
                  pendingPRNumbers.push(prNum);
                  console.log(`PR #${prNum} has pending validation check`);
                }
              } catch (error) {
                console.log(`Could not check status for PR #${prNum}: ${error.message}`);
              }
            }
            
            core.setOutput('has_pending', hasPendingChecks.toString());
            core.setOutput('pending_prs', pendingPRNumbers.join(','));
            
            return { hasPendingChecks, pendingPRNumbers };

      - name: Determine validation result
        id: validation_result
        if: steps.extract_issues.outputs.has_issues == 'true'
        run: |
          EXACT_MATCH="${{ steps.validate_matching.outputs.exact_match_found }}"
          OVERRIDE="${{ steps.check_override.outputs.override_approved }}"
          IMBALANCE_EXCEEDED="${{ steps.check_imbalance.outputs.imbalance_exceeded }}"
          PRIMARY_COUNT=${{ steps.query_linked_prs.outputs.primary_count }}
          RELEASE_COUNT=${{ steps.query_linked_prs.outputs.release_count }}
          HAS_PENDING="${{ steps.check_pending.outputs.has_pending }}"
          PENDING_PRS="${{ steps.check_pending.outputs.pending_prs }}"
          
          # Validation logic with pending check handling
          if [ "$OVERRIDE" = "true" ]; then
            RESULT="PASS_OVERRIDE"
            MESSAGE="‚úÖ Validation PASSED (Override approved)"
            SHOULD_BLOCK="false"
          elif [ "$EXACT_MATCH" = "true" ]; then
            if [ "$IMBALANCE_EXCEEDED" = "true" ]; then
              RESULT="WARN_IMBALANCE"
              MESSAGE="‚ö†Ô∏è Validation WARNING: Matching PRs found but branch imbalance detected"
              SHOULD_BLOCK="false"
            else
              RESULT="PASS"
              MESSAGE="‚úÖ Validation PASSED: Matching PRs found in both branches"
              SHOULD_BLOCK="false"
            fi
          elif [ "$HAS_PENDING" = "true" ]; then
            # NEW: Handle pending checks in comparison branch
            RESULT="PENDING"
            MESSAGE="‚è≥ Validation PENDING: Waiting for validation to complete in comparison branch (PR(s) #${PENDING_PRS})"
            SHOULD_BLOCK="false"
          elif [ $PRIMARY_COUNT -eq 0 ] || [ $RELEASE_COUNT -eq 0 ]; then
            RESULT="FAIL_MISSING"
            MESSAGE="‚ùå Validation FAILED: No matching PR found in comparison branch"
            SHOULD_BLOCK="true"
          else
            RESULT="FAIL_MISMATCH"
            MESSAGE="‚ùå Validation FAILED: Issue references don't match exactly"
            SHOULD_BLOCK="true"
          fi
          
          echo "result=$RESULT" >> $GITHUB_OUTPUT
          echo "message=$MESSAGE" >> $GITHUB_OUTPUT
          echo "should_block=$SHOULD_BLOCK" >> $GITHUB_OUTPUT
          echo "$MESSAGE"

      - name: Update all related PRs with synchronized status
        id: sync_status
        if: steps.query_linked_prs.outputs.total_prs > 0
        uses: actions/github-script@v7
        with:
          script: |
            const primaryPRs = '${{ steps.query_linked_prs.outputs.primary_prs }}'.split(',').filter(n => n);
            const releasePRs = '${{ steps.query_linked_prs.outputs.release_prs }}'.split(',').filter(n => n);
            const allPRs = [...primaryPRs, ...releasePRs];
            
            const validationResult = '${{ steps.validation_result.outputs.result }}';
            const validationMessage = '${{ steps.validation_result.outputs.message }}';
            const shouldBlock = '${{ steps.validation_result.outputs.should_block }}' === 'true';
            const issueRefs = '${{ steps.extract_issues.outputs.issue_refs }}';
            const matchingPRs = '${{ steps.validate_matching.outputs.matching_pr_numbers }}';
            const timestamp = '${{ steps.context.outputs.timestamp }}';
            const imbalance = '${{ steps.check_imbalance.outputs.imbalance }}';
            
            // Build status comment
            let commentBody = `## üîÑ Cross-Branch Validation Status
            
            **Last Updated:** ${timestamp}
            **Validation Result:** ${validationMessage}
            **Issue References:** ${issueRefs}
            
            ### üìä PR Distribution
            - **${{ env.PRIMARY_BRANCH }}:** ${primaryPRs.length} PR(s) ${primaryPRs.length > 0 ? `(#${primaryPRs.join(', #')})` : ''}
            - **${{ env.RELEASE_BRANCH }}:** ${releasePRs.length} PR(s) ${releasePRs.length > 0 ? `(#${releasePRs.join(', #')})` : ''}
            - **Branch Imbalance:** ${imbalance}
            
            `;
            
            if (validationResult === 'PENDING') {
              const pendingPRs = '${{ steps.check_pending.outputs.pending_prs }}';
              commentBody += `### ‚è≥ Validation Pending
            
            This PR is waiting for validation checks to complete in the comparison branch.
            
            **Pending PRs:** #${pendingPRs}
            
            Once the validation completes in the comparison branch, this PR will be automatically updated.
            **No manual action required** - the system will sync automatically.
            
            `;
            } else if (matchingPRs) {
              commentBody += `### ‚úÖ Matching PRs Found
            - PR(s) #${matchingPRs} in comparison branch contain the same issue references
            
            `;
            }
            
            if (shouldBlock) {
              commentBody += `### ‚ö†Ô∏è Action Required
            
            This PR is **blocked** from merging. To proceed, you must either:
            
            1. **Create a matching PR** in the comparison branch with the same issue references
            2. **Add the override label** \`${{ env.OVERRIDE_LABEL }}\` with justification
            
            #### Override Instructions:
            1. Add label: \`${{ env.OVERRIDE_LABEL }}\`
            2. Comment with justification (e.g., "This fix is specific to ${{ github.event.pull_request.base.ref }} only")
            3. Re-run this workflow
            
            `;
            }
            
            commentBody += `---
            *Workflow Run: [#${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*`;
            
            // Update each related PR
            for (const prNumber of allPRs) {
              try {
                // Find existing validation comment
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(prNumber)
                });
                
                const botComment = comments.data.find(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('Cross-Branch Validation Status')
                );
                
                if (botComment) {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: botComment.id,
                    body: commentBody
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(prNumber),
                    body: commentBody
                  });
                }
                
                // Update labels
                if (shouldBlock) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(prNumber),
                    labels: ['${{ env.BLOCK_LABEL }}']
                  });
                } else {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: parseInt(prNumber),
                      name: '${{ env.BLOCK_LABEL }}'
                    });
                  } catch (error) {
                    // Label might not exist
                  }
                }
                
                console.log(`‚úÖ Updated PR #${prNumber}`);
              } catch (error) {
                console.error(`‚ùå Failed to update PR #${prNumber}:`, error.message);
              }
            }
            
            return {
              updatedPRs: allPRs.length,
              validationResult: validationResult
            };

      - name: Set pending status for waiting PRs
        if: steps.validation_result.outputs.result == 'PENDING'
        run: |
          echo "::notice::Validation is pending - waiting for checks in comparison branch to complete"
          echo "::notice::This PR will be automatically updated once comparison branch validation completes"
          echo "Pending PRs: ${{ steps.check_pending.outputs.pending_prs }}"

      - name: Block merge if validation fails
        if: |
          steps.validation_result.outputs.should_block == 'true' &&
          steps.check_override.outputs.override_approved != 'true' &&
          steps.validation_result.outputs.result != 'PENDING'
        run: |
          echo "::error::Cross-branch validation failed. See PR comments for details."
          echo "::error::Add label '${{ env.OVERRIDE_LABEL }}' to override this check."
          exit 1

      - name: Validation summary
        if: always()
        run: |
          echo "=== Enhanced Cross-Branch Validation Summary ==="
          echo "Timestamp: ${{ steps.context.outputs.timestamp }}"
          echo "Trigger: ${{ steps.context.outputs.trigger_event }}"
          echo "Issue References: ${{ steps.extract_issues.outputs.issue_refs }}"
          echo "Total Related PRs: ${{ steps.query_linked_prs.outputs.total_prs }}"
          echo "Validation Result: ${{ steps.validation_result.outputs.result }}"
          echo "Should Block: ${{ steps.validation_result.outputs.should_block }}"
          echo "Override Approved: ${{ steps.check_override.outputs.override_approved }}"
          echo "=============================================="

# Made with Bob
