name: Enhanced Cross-Branch PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, closed, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to revalidate (optional - validates all if empty)'
        required: false
      issue_number:
        description: 'Issue number to revalidate all related PRs (optional)'
        required: false

# Configuration: Update these for each release cycle
env:
  PRIMARY_BRANCH: 'main'
  RELEASE_BRANCH: 'checking-2'
  # Validation rules
  REQUIRE_EXACT_MATCH: 'true'           # All issue refs must match exactly
  ALLOW_DRAFT_PRS: 'false'              # Include draft PRs in validation
  MAX_BRANCH_IMBALANCE: '2'             # Max difference in PR count between branches
  OVERRIDE_LABEL: 'approved:single-branch-merge'
  BLOCK_LABEL: 'merge-blocked:cross-branch-validation'

jobs:
  validate-cross-branch:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      contents: read
      statuses: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup validation context
        id: context
        run: |
          echo "timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          echo "workflow_run_id=${{ github.run_id }}" >> $GITHUB_OUTPUT
          echo "trigger_event=${{ github.event_name }}" >> $GITHUB_OUTPUT
          
          # Determine which PR triggered this (if any)
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "trigger_pr=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.pr_number }}" ]; then
            echo "trigger_pr=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "trigger_pr=none" >> $GITHUB_OUTPUT
          fi

      - name: Extract all issue references from current PR
        id: extract_issues
        if: github.event_name == 'pull_request'
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_TEXT="$PR_TITLE $PR_BODY"
          
          # Extract issue URLs from markdown hyperlinks [#N](url)
          ISSUE_URLS=$(echo "$PR_TEXT" | grep -oP '\[#\d+\]\(\K[^)]+(?=\))' | grep 'github.com.*issues' | sort -u | tr '\n' ',' | sed 's/,$//')
          
          if [ -z "$ISSUE_URLS" ]; then
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ No issue references found in PR"
          else
            echo "has_issues=true" >> $GITHUB_OUTPUT
            echo "issue_refs=$ISSUE_URLS" >> $GITHUB_OUTPUT
            echo "issue_count=$(echo $ISSUE_URLS | tr ',' '\n' | wc -l)" >> $GITHUB_OUTPUT
            echo "âœ… Found issue URLs: $ISSUE_URLS"
          fi
      - name: Query GitHub GraphQL for all linked PRs
        id: query_linked_prs
        if: steps.extract_issues.outputs.has_issues == 'true' || github.event.inputs.issue_number
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Determine which issues to query
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.issue_number }}" ]; then
            ISSUE_NUMBERS="${{ github.event.inputs.issue_number }}"
          else
            ISSUE_URLS="${{ steps.extract_issues.outputs.issue_refs }}"
            ISSUE_NUMBERS=$(echo "$ISSUE_URLS" | tr ',' '\n' | grep -oP 'issues/\K\d+' | tr '\n' ',' | sed 's/,$//')
          fi
          
          echo "Querying issues: $ISSUE_NUMBERS"
          
          # Initialize empty array for all PRs
          > all_linked_prs_temp.json
          
          # Query each issue individually using GraphQL
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUE_NUMBERS"
          for ISSUE_REF in "${ISSUE_ARRAY[@]}"; do
            ISSUE_NUM=$(echo "$ISSUE_REF" | sed 's/#//g')
            
            QUERY='query($owner: String!, $repo: String!, $issueNumber: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $issueNumber) {
                  number
                  title
                  timelineItems(itemTypes: [CROSS_REFERENCED_EVENT], first: 100) {
                    nodes {
                      ... on CrossReferencedEvent {
                        source {
                          ... on PullRequest {
                            number
                            title
                            body
                            baseRefName
                            state
                            isDraft
                            url
                            labels(first: 20) {
                              nodes {
                                name
                              }
                            }
                            author {
                              login
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }'
            
            RESULT=$(gh api graphql \
              -f query="$QUERY" \
              -f owner="${{ github.repository_owner }}" \
              -f repo="${{ github.event.repository.name }}" \
              -F issueNumber="$ISSUE_NUM" 2>&1)
            
            if [ $? -eq 0 ]; then
              echo "$RESULT" | jq -c '.data.repository.issue.timelineItems.nodes[].source' >> all_linked_prs_temp.json
            else
              echo "âš ï¸ Failed to query issue #$ISSUE_NUM"
            fi
          done
          
          # Combine all PRs and remove duplicates
          if [ -s all_linked_prs_temp.json ]; then
            jq -s 'unique_by(.number)' all_linked_prs_temp.json > all_linked_prs.json
          else
            echo "[]" > all_linked_prs.json
          fi
          rm -f all_linked_prs_temp.json
          
          # Count PRs by branch
          if [ "${{ env.ALLOW_DRAFT_PRS }}" = "false" ]; then
            FILTER_DRAFT='and .isDraft == false'
          else
            FILTER_DRAFT=''
          fi
          
          PRIMARY_PRS=$(jq -r --arg branch "${{ env.PRIMARY_BRANCH }}" \
            '.[] | select(.baseRefName == $branch and .state == "OPEN" '"$FILTER_DRAFT"') | .number' \
            all_linked_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          RELEASE_PRS=$(jq -r --arg branch "${{ env.RELEASE_BRANCH }}" \
            '.[] | select(.baseRefName == $branch and .state == "OPEN" '"$FILTER_DRAFT"') | .number' \
            all_linked_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          # Count PRs safely
          if [ -z "$PRIMARY_PRS" ] || [ "$PRIMARY_PRS" = " " ]; then
            PRIMARY_COUNT=0
            PRIMARY_PRS=""
          else
            PRIMARY_COUNT=$(echo "$PRIMARY_PRS" | wc -w)
          fi
          
          if [ -z "$RELEASE_PRS" ] || [ "$RELEASE_PRS" = " " ]; then
            RELEASE_COUNT=0
            RELEASE_PRS=""
          else
            RELEASE_COUNT=$(echo "$RELEASE_PRS" | wc -w)
          fi
          
          # Output results
          echo "primary_prs=$(echo $PRIMARY_PRS | tr ' ' ','  | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "release_prs=$(echo $RELEASE_PRS | tr ' ' ',' | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "primary_count=$PRIMARY_COUNT" >> $GITHUB_OUTPUT
          echo "release_count=$RELEASE_COUNT" >> $GITHUB_OUTPUT
          echo "total_prs=$((PRIMARY_COUNT + RELEASE_COUNT))" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š PR Distribution:"
          echo "  - ${{ env.PRIMARY_BRANCH }}: $PRIMARY_COUNT PRs"
          echo "  - ${{ env.RELEASE_BRANCH }}: $RELEASE_COUNT PRs"
      - name: Filter PRs by matching issue URLs
        id: filter_prs
        if: steps.extract_issues.outputs.has_issues == 'true' && steps.query_linked_prs.outputs.total_prs > 0
        run: |
          CURRENT_ISSUE_URLS="${{ steps.extract_issues.outputs.issue_refs }}"
          echo "Current PR issue URLs: $CURRENT_ISSUE_URLS"
          
          # Convert comma-separated URLs to array for processing
          IFS=',' read -ra CURRENT_URLS_ARRAY <<< "$CURRENT_ISSUE_URLS"
          
          # Create a filtered JSON with only PRs that have matching issue URLs
          echo "[]" > filtered_prs.json
          
          # Get total number of PRs
          TOTAL_PRS=$(jq 'length' all_linked_prs.json)
          echo "Total PRs to check: $TOTAL_PRS"
          
          # Check each PR
          for ((i=0; i<$TOTAL_PRS; i++)); do
            PR_NUM=$(jq -r ".[$i].number" all_linked_prs.json)
            PR_BODY=$(jq -r ".[$i].body // empty" all_linked_prs.json)
            PR_TITLE=$(jq -r ".[$i].title // empty" all_linked_prs.json)
            PR_TEXT="$PR_TITLE $PR_BODY"
            
            echo "Checking PR #$PR_NUM..."
            
            # Extract issue URLs from this PR's body
            PR_ISSUE_URLS=$(echo "$PR_TEXT" | grep -oP '\[#\d+\]\(\K[^)]+(?=\))' | grep 'github.com.*issues' | sort -u | tr '\n' ',' | sed 's/,$//')
            
            if [ -z "$PR_ISSUE_URLS" ]; then
              echo "  PR #$PR_NUM has no issue URLs, skipping"
              continue
            fi
            
            echo "  PR #$PR_NUM issue URLs: $PR_ISSUE_URLS"
            
            # Convert PR URLs to sorted array for comparison
            IFS=',' read -ra PR_URLS_ARRAY <<< "$PR_ISSUE_URLS"
            PR_URLS_SORTED=$(printf '%s\n' "${PR_URLS_ARRAY[@]}" | sort | tr '\n' ',' | sed 's/,$//')
            CURRENT_URLS_SORTED=$(printf '%s\n' "${CURRENT_URLS_ARRAY[@]}" | sort | tr '\n' ',' | sed 's/,$//')
            
            # Check if URLs match exactly
            echo "PR_URLS_SORTED : $PR_URLS_SORTED"
            echo "CURRENT_URLS_SORTED : $CURRENT_URLS_SORTED"
            if [ "$PR_URLS_SORTED" = "$CURRENT_URLS_SORTED" ]; then
              echo "  :white_check_mark: PR #$PR_NUM has matching issue URLs"
              # Add this PR to filtered list
              jq --slurpfile existing filtered_prs.json --argjson idx "$i" \
              '$existing[0] + [.[$idx]]' all_linked_prs.json > filtered_prs_temp.json
              mv filtered_prs_temp.json filtered_prs.json
            else
              echo "  :x: PR #$PR_NUM has different issue URLs"
            fi
          done
          
          # Filter to only OPEN PRs with PRIMARY or RELEASE branch as base
          if [ "${{ env.ALLOW_DRAFT_PRS }}" = "false" ]; then
            FILTER_DRAFT='and .isDraft == false'
          else
            FILTER_DRAFT=''
          fi
          
          jq --arg primary "${{ env.PRIMARY_BRANCH }}" --arg release "${{ env.RELEASE_BRANCH }}" \
            '[.[] | select(.state == "OPEN" and (.baseRefName == $primary or .baseRefName == $release) '"$FILTER_DRAFT"')]' \
            filtered_prs.json > filtered_prs_temp.json
          mv filtered_prs_temp.json filtered_prs.json
          
          # Count filtered PRs by branch
          FILTERED_PRIMARY_PRS=$(jq -r --arg branch "${{ env.PRIMARY_BRANCH }}" \
            '.[] | select(.baseRefName == $branch) | .number' \
            filtered_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          FILTERED_RELEASE_PRS=$(jq -r --arg branch "${{ env.RELEASE_BRANCH }}" \
            '.[] | select(.baseRefName == $branch) | .number' \
            filtered_prs.json 2>/dev/null | sort -u | tr '\n' ' ')
          
          # Count filtered PRs safely
          if [ -z "$FILTERED_PRIMARY_PRS" ] || [ "$FILTERED_PRIMARY_PRS" = " " ]; then
            FILTERED_PRIMARY_COUNT=0
            FILTERED_PRIMARY_PRS=""
          else
            FILTERED_PRIMARY_COUNT=$(echo "$FILTERED_PRIMARY_PRS" | wc -w)
          fi
          
          if [ -z "$FILTERED_RELEASE_PRS" ] || [ "$FILTERED_RELEASE_PRS" = " " ]; then
            FILTERED_RELEASE_COUNT=0
            FILTERED_RELEASE_PRS=""
          else
            FILTERED_RELEASE_COUNT=$(echo "$FILTERED_RELEASE_PRS" | wc -w)
          fi
          
          # Output filtered results
          echo "filtered_primary_prs=$(echo $FILTERED_PRIMARY_PRS | tr ' ' ','  | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "filtered_release_prs=$(echo $FILTERED_RELEASE_PRS | tr ' ' ',' | sed 's/,$//' | sed 's/^,//')" >> $GITHUB_OUTPUT
          echo "filtered_primary_count=$FILTERED_PRIMARY_COUNT" >> $GITHUB_OUTPUT
          echo "filtered_release_count=$FILTERED_RELEASE_COUNT" >> $GITHUB_OUTPUT
          echo "filtered_total_prs=$((FILTERED_PRIMARY_COUNT + FILTERED_RELEASE_COUNT))" >> $GITHUB_OUTPUT
          
          echo ""
          echo ":bar_chart: Filtered PR Distribution (matching issue URLs only):"
          echo "  - ${{ env.PRIMARY_BRANCH }}: $FILTERED_PRIMARY_COUNT PRs ($FILTERED_PRIMARY_PRS)"
          echo "  - ${{ env.RELEASE_BRANCH }}: $FILTERED_RELEASE_COUNT PRs ($FILTERED_RELEASE_PRS)"
          echo ""
          echo "=== Filtered PRs JSON ==="
          cat filtered_prs.json
      - name: Validate issue reference matching
        id: validate_matching
        if: steps.filter_prs.outputs.filtered_total_prs > 0
        run: |
          PRIMARY_COUNT=${{ steps.filter_prs.outputs.filtered_primary_count }}
          RELEASE_COUNT=${{ steps.filter_prs.outputs.filtered_release_count }}
          PRIMARY_PRS="${{ steps.filter_prs.outputs.filtered_primary_prs }}"
          RELEASE_PRS="${{ steps.filter_prs.outputs.filtered_release_prs }}"
          
          echo "Primary branch (${{ env.PRIMARY_BRANCH }}): $PRIMARY_COUNT PRs"
          echo "Release branch (${{ env.RELEASE_BRANCH }}): $RELEASE_COUNT PRs"
          
          # Check if PR counts match
          if [ $PRIMARY_COUNT -eq $RELEASE_COUNT ] && [ $PRIMARY_COUNT -gt 0 ]; then
            echo "validation_result=success" >> $GITHUB_OUTPUT
            echo "matching_pr_numbers=$RELEASE_PRS" >> $GITHUB_OUTPUT
            echo "should_block=false" >> $GITHUB_OUTPUT
            echo "âœ… Validation SUCCESS: PR counts match ($PRIMARY_COUNT in each branch)"
          else
            echo "validation_result=failure" >> $GITHUB_OUTPUT
            echo "matching_pr_numbers=" >> $GITHUB_OUTPUT
            echo "should_block=true" >> $GITHUB_OUTPUT
            echo "âŒ Validation FAILURE: PR count mismatch (Primary: $PRIMARY_COUNT, Release: $RELEASE_COUNT)"
          fi
      - name: Post validation result to PR
        if: steps.validate_matching.outputs.validation_result && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const validationResult = '${{ steps.validate_matching.outputs.validation_result }}';
            const primaryCount = '${{ steps.filter_prs.outputs.filtered_primary_count }}';
            const releaseCount = '${{ steps.filter_prs.outputs.filtered_release_count }}';
            const primaryPRs = '${{ steps.filter_prs.outputs.filtered_primary_prs }}';
            const releasePRs = '${{ steps.filter_prs.outputs.filtered_release_prs }}';
            const issueRefs = '${{ steps.extract_issues.outputs.issue_refs }}';
            const targetBranch = '${{ github.event.pull_request.base.ref }}';
            const primaryBranch = '${{ env.PRIMARY_BRANCH }}';
            const releaseBranch = '${{ env.RELEASE_BRANCH }}';
            const compareBranch = targetBranch === primaryBranch ? releaseBranch : primaryBranch;
            
            let commentBody;
            
            if (validationResult === 'success') {
              commentBody = `âœ… **Cross-Branch Validation: PASSED**
              
              This PR references issue(s) and corresponding PR(s) exist in both branches with matching issue references.
              
              **Status:** Merge validation successful - both branches will receive this fix.
              
              ### ðŸ“Š PR Distribution
              - **${primaryBranch}:** ${primaryCount} PR(s) ${primaryPRs ? `(#${primaryPRs.split(',').join(', #')})` : ''}
              - **${releaseBranch}:** ${releaseCount} PR(s) ${releasePRs ? `(#${releasePRs.split(',').join(', #')})` : ''}
              
              **Issue References:** ${issueRefs}`;
              
              // Remove blocking label
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: '${{ env.BLOCK_LABEL }}'
                });
              } catch (error) {
                // Label might not exist
              }
              
            } else {
              commentBody = `âš ï¸ **Cross-Branch Validation: REQUIRES REVIEW**
              
              This PR references issue(s) but **PR count mismatch** detected between branches.
              
              **âš ï¸ MERGE BLOCKED - REVIEWER ACTION REQUIRED**
              
              ### ðŸ“Š PR Distribution
              - **${primaryBranch}:** ${primaryCount} PR(s) ${primaryPRs ? `(#${primaryPRs.split(',').join(', #')})` : ''}
              - **${releaseBranch}:** ${releaseCount} PR(s) ${releasePRs ? `(#${releasePRs.split(',').join(', #')})` : ''}
              
              **Issue References:** ${issueRefs}
              
              ---
              
              ### Override Instructions
              
              If this fix is intentionally being merged into **only** the \`${targetBranch}\` branch, a reviewer must:
              
              1. **Acknowledge the risk** of potential inconsistency between branches
              2. **Add the label** \`${{ env.OVERRIDE_LABEL }}\` to this PR
              3. **Comment** with justification for the single-branch merge
              
              **Example justification:**
              > "Approved for single-branch merge. This fix is specific to ${targetBranch} and does not apply to ${compareBranch} because [reason]."
              
              ---
              
              ### Creating a Matching PR
              
              Alternatively, create a PR for \`${compareBranch}\` that:
              - References the same issue(s)
              - Contains the equivalent fix for that branch
              
              Once the matching PR is created, re-run this workflow by updating this PR.`;
              
              // Add blocking label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['${{ env.BLOCK_LABEL }}']
              });
            }
            
            // Post or update comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Cross-Branch Validation')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
      
      - name: Check for override approval
        id: check_override
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(label => label.name);
            const hasOverride = labels.includes('${{ env.OVERRIDE_LABEL }}');
            
            core.setOutput('override_approved', hasOverride.toString());
            
            if (hasOverride) {
              console.log('âœ… Override label found - validation will be bypassed');
            }
            
            return hasOverride;

      - name: Block merge if validation fails
        if: |
          steps.validate_matching.outputs.should_block == 'true' &&
          steps.check_override.outputs.override_approved != 'true'
        run: |
          echo "::error::Cross-branch validation failed. See PR comments for details."
          echo "::error::Add label '${{ env.OVERRIDE_LABEL }}' to override this check."
          exit 1

# Made with Bob
